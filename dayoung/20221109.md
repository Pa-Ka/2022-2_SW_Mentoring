# 회원가입 구현
_22.11.09 study_
***
## 회원모델생성
> 회원 정보를 위한 모델이 필요하다.

1. 회원 정보 모델의 속성
    - username : 사용자이름(ID)
    - password : 비밀번호
    - email : 이메일
2. User 모델 작성
```python
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
```
- id는 자동으로 증가하는 기본키
- nullable=False : username, password, email에 null 값을 허용하지 않도록
- unique=True : username, email에는 같은 값을 저장할 수 없다는 의미
> 이제 모델이 만들어졌으니 리비전 파일 생성 :: 터미널창에 flask db migrate / flask db upgrade 명령 실행

## 회원가입 폼 생성
> 회원가입을 위한 일종의 설문지
```python
class UserCreateForm(FlaskForm):
    username = StringField('사용자이름', validators=[DataRequired(), Length(min=3, max=25)])
    password1 = PasswordField('비밀번호', validators=[
        DataRequired(), EqualTo('password2', '비밀번호가 일치하지 않습니다')])
    password2 = PasswordField('비밀번호확인', validators=[DataRequired()])
    email = EmailField('이메일', validators=[DataRequired(), Email()])
```
- validators=[DataRequired(), Length(min=3, max=25)] : username은 필수항목이고 길이가 3-25사이여야한다는 검증조건
- password1/2 : 비밀번호와 비밀번호 확인에 대한 필드
- PasswordField : StringField와 비슷하지만 템플릿에서 자동변환으로 사용시 input type="password" 태그로 변환
- EqualTo : 모두 필수값이어야하고 두개의 값이 일치해야하는 검증 속성
- EmailField : StringField와 동일하지만 템플릿 자동변화느로 사용시 input type="email" 태그로 변환
- Email() : 해당 속성의 값이 이메일 형식과 일치하는지를 검증

## 회원가입 구현
> 회원가입을 위한 블루프린트를 만들어 로그인 로그아웃까지 만들기
1. 블루 프린트
```python
bp = Blueprint('auth', __name__, url_prefix='/auth')

@bp.route('/signup/', methods=('GET', 'POST'))
def signup():
    form = UserCreateForm()
    if request.method == 'POST' and form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if not user:
            user = User(username=form.username.data,
                        password=generate_password_hash(form.password1.data),
                        email=form.email.data)
            db.session.add(user)
            db.session.commit()
            return redirect(url_for('main.index'))
        else:
            flash('이미 존재하는 사용자입니다.')
    return render_template('auth/signup.html', form=form)
```
- 블루프린트 객체 생성 : /auth/로 시작하는 url이 호출되면 auth_views.py파일의 함수들이 호출
- signup 함수 : 회원가입을 위한 함수로, POST방식으로 계정을 저장, GET방식으로 계정 등록화면을 출력
- flash('이미 존재하는 사용자입니다.') : username으로 중복되는지 확인하고 오류발생/ flash함수는 논리오류를 발생 이를 받아서 템플릿에 표시해야함
- generate_password_hash : 비밀번호 암호화를 위한 함수 (복호화 불가능/ 항상 암호화된것으로 비교)

2. 블루프린트 등록
> 블루프린트를 사용하려면 init.py 파일에 등록해야함
- auth_views를 임포트후, app.register_blueprint(auth_view.bp)로 등록

3. 회원가입 템플릿
```html
{% extends "base.html" %}
{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">계정생성</h5>
    <form method="post">
        {{ form.csrf_token }}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자 이름</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="password1">비밀번호</label>
            <input type="password" class="form-control" name="password1" id="password1"
                   value="{{ form.password1.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="password2">비밀번호 확인</label>
            <input type="password" class="form-control" name="password2" id="password2"
                   value="{{ form.password2.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="email">이메일</label>
            <input type="text" class="form-control" name="email" id="email"
                   value="{{ form.email.data or '' }}">
        </div>
        <button type="submit" class="btn btn-primary">생성하기</button>
    </form>
</div>
{% endblock %}
```
- input 태그 : 사용자이름 비밀번호 비밀번호확인 이메일에 해당되는 값 받기
- 생성하기 버튼 : 폼데이터가 POST방식으로 /auth/signup/ URL로 요청된다.
- form 태그에 action속성이 지정되지 않은 경우에는 현재의 URL로 폼이 전송 
- {% include "form_errors.html" %} : 회원가입할때 발생할 수 있는 오류를 표시

4. 오류표시하기
> 필드에서 발생한 오류를 표시하는 부분과 flash를 거치면서 발생한 오류를 표시하는 부분으로 구성

```html
<!-- 필드오류 -->
{% if form.errors %}
<div class="alert alert-danger" role="alert">
    {% for field, errors in form.errors.items() %}
    <strong>{{ form[field].label }}</strong>
    <ul>
        {% for error in errors %}
        <li>{{ error }}</li>
        {% endfor %}
    </ul>
    {% endfor %}
</div>
{% endif %}
<!-- flash 오류 -->
{% for message in get_flashed_messages() %}
<div class="alert alert-danger" role="alert">
    {{ message }}
</div>
{% endfor %}
```
- 필드오류 : 폼 validators 검증에 실패한 경우 표시
- flash 오류 : flash()함수에 의하여 표시

5. 회원가입 링크
- nav-link 클래스의 a태그에 {{ url_for('auth.signup') }}을 href 속성으로

6. 회원 데이터 확인
- flask shell 명령으로 계정 정보 확인가능
## 로그인
> 로그인 정보가 있어야 질문한 사람, 답변한 사람이 누구인지 구별 가능
1. 로그인 폼 생성
```python
class UserLoginForm(FlaskForm):
    username = StringField('사용자이름', validators=[DataRequired(), Length(min=3, max=25)])
    password = PasswordField('비밀번호', validators=[DataRequired()])
```
- username, password 필드를 추가하고 필수입력 항목으로 지정
2. 로그인 라우팅 함수
```python
@bp.route('/login/', methods=('GET', 'POST'))
def login():
    form = UserLoginForm()
    if request.method == 'POST' and form.validate_on_submit():
        error = None
        user = User.query.filter_by(username=form.username.data).first()
        if not user:
            error = "존재하지 않는 사용자입니다."
        elif not check_password_hash(user.password, form.password.data):
            error = "비밀번호가 올바르지 않습니다."
        if error is None:
            session.clear()
            session['user_id'] = user.id
            return redirect(url_for('main.index'))
        flash(error)
    return render_template('auth/login.html', form=form)
```
- login 함수 : signup 함수와 비슷하게 동작 / POST 방식에는 로그인 수행, GET 요청에는 로그인 화면을 보여줌
- POST 요청에 의해 로그인하는 과정
  1. username으로 데이터 베이스에 해당사용자가 있는지 검사
  2. 사용자가 없다면 "오류발생" , 사용자가 존재한다면 폼입력으로 받은 password와 check_password_hash 함수를 사용하여 데이터 베이스의 비밀번호와 일치하는지를 비교
  3. 사용자도 존재하고 비밀번호도 일치한다면 플라스크 세션에 사용자 정보를 저장 (user_id라는 문자열을 세션키에 저장)
  4. 여기서 세션이란 ? request와는 달리 한번 생성하면 그 값을 계속 유지 / 브라우저 별로 생성되는 메모리공간
  5. 세션에 사용자의 id값을 저장하면 다양한 URL요청에 이세션에 저장된 값을 읽을 수 있다. (세션정보를 확인하여 현재 요청한 주체가 로그인한 사용자인지 아닌지를 판별)
- 쿠키와 세션 : 웹프로그램은 웹브라우저에서 요청이되면 서버가 응답하는 순서로 실행되며, 서버응답이 완료되면 웹 브라우저와 서버 사이의 네트워크 연결이 끊어진다. 하지만 수많은 브라우저가 서버에 요청할 때마다 매번 새로운 세션이 생성되는 것이 아니라 동일한 브라우저의 요청에서 서버는 동일한 세션을 사용한다.
이때, 서버와의 연결이 끊어진 웹이 세션을 계속 유지할수있는 방법이 쿠키이다.

3. 로그인 템플릿
```html
{% extends "base.html" %}
{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">로그인</h5>
    <form method="post">
        {{ form.csrf_token }}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자 이름</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="password">비밀번호</label>
            <input type="password" class="form-control" name="password" id="password"
                   value="{{ form.password.data or '' }}">
        </div>
        <button type="submit" class="btn btn-primary">로그인</button>
    </form>
</div>
{% endblock %}
```
- 로그인 버튼을 누르면 form 엘리먼트가 POST방식으로 현재 웹 브라우저의 주소창에 표시된 URL인 / auth/login/으로 요청

4. 로그인 링크
- {{ url_for('auth.login') }}을 navbor파일의 로그인 링크에 연결

## 로그아웃
> 로그인 이후에도 내비게이션 바에는 여전히 로그인 링크가 남았다. 이 링크가 로그아웃 링크로 바뀌어야한다.

1. 로그인 여부 확인
```python
@bp.before_app_request
def load_logged_in_user():
    user_id = session.get('user_id')
    if user_id is None:
        g.user = None
    else:
        g.user = User.query.get(user_id)
```
- @bp.before_app_request : 애너테이션으로 이것은 모든 파일의 라우팅 함수보다 항상 먼저 실행된다.
- g : 플라스크의 컨텍스트 변수로 request변수와 마찬가지로 요청에서 응답까지의 과정에서 유효하다. session변수에 user_id값이 있으면 데이터 베이스에서 사용자 정보를 조회하여 g.user에 저장한다.
이렇게 하면 이후 사용자 로그인 검사를 할때 session을 조사할 필요가 없다.
- g.user : User 객체가 저장

2. 로그인 로그아웃 표시
- {% if g.user %} 코드를 추가하여 사용자의 로그인 유무를 판별
3. 로그아웃 라우팅 함수
```python
@bp.route('/logout/')
def logout():
    session.clear()
    return redirect(url_for('main.index'))
```
- session.clear() : 세션의 모든 값을 삭제
- load_logged_in_user 함수에서 session의 값을 읽을 수 없으므로 g.user도 None이 된다.
4. 로그아웃 링크
- {{ url_for('auth.logout') }} 링크를 추가하여 내비게이션 바 수정